<!DOCTYPE html>
<html>
	<head>
		<!--- 

			bootstrap css is auto injected by the parent frame

			<link id="cssChanges" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"> 

		---->
		<meta charset="utf-8" />
		<title>Import for Etherscan</title>
	</head>
	<body>

		<script src="./js/remix/plugin/plugin_iframe.js"></script>
		<script>

			function sleep(ms) {

				return new Promise(resolve => setTimeout(resolve, ms));

			}

			ContractRequest.REQUEST_NOT_ATTEMPTED = 0 << 0;
			ContractRequest.REQUEST_RUNNING = 1 << 0;
			ContractRequest.REQUEST_SUCCESSFUL = 1 << 1;
			ContractRequest.REQUEST_FAILED = 1 << 2;
			ContractRequest.LAST_SAVE_SUCCESSFUL = 1 << 3;
			
			function ContractRequest(address) {
				
				this.state = ContractRequest.REQUEST_NOT_ATTEMPTED;
				this.address = address;
				this.attempts = 0;
				this.lastAPIResult = "";
				
				this.lastParsedResult = {};
				this.contractData = {};

				// i didn't want to set the storage location on creation, because someone might want to make a 
				// request + save then save again somewhere else. these are just strings with the location of successful saves
				this.storedAtLocations = [];

				
				// if someone pulls the contract again after modifying a pulled contract,
				// it will overwrite their work. saving a time is unique enough to prevent
				// this from happening, and is also useful when looking directly at contract addresses
				this.time = new Date().getTime();
				
				// all results from the api are saved with the corresponding attempt number
				this.apiResults = [];
				
				this.UIUpdatesCallback = (dataForCallbackUpdates) => {};
				
				this.setUICallback = function(UICallback) {
				
					this.UIUpdatesCallback = UICallback;

					this.UIUpdatesCallback(this);
				
				}
				
				this.saveSourcesToRemixClient = async function(remixClient, storeLocation) {


					let dateString = String(new Date(Number(this.time)).toLocaleString()).replaceAll(":", "_").replaceAll("/", "-").replaceAll(",", "");

					// in the future, i might add the ability to customize this. 
					//
					// the current format is { unixTime } / { formattedLocaleTime } / { address } 
					// 
					// the argument for this format is below
					//
					// 	leading with the initiated DateTime unix time
					//		- helps with confusion related to address sort - "i remember requesting this one before that one, 
					//			but don't remember what address that was"
					//  	- automatically orders all saved contracts in this folder with a unique natural ID. this saves
					//			someone who modifies a contract from accidentally writing over it if they request
					//			a new version for comparison. 
					//		- it forces a correct sort by creation date
					//
					//	followed by the actual formatted date
					//		- it makes the order immediately obvious, and is helpful when it's been a while since reviewing a contract
					//		- it prevents someone from confusing where the requested contract will be stored. ex. if they perceived
					// 			the unix time as an id, the order might appear { id } / { address } / { time }. so they might believe
					//			that future requests could end up with a different time under the address, which wouldn't be so bad,
					//			however, i didn't want to do the small amount of work to make this reality when i like the this format more
					//	
					// 	and finally, followed by the address
					//	- the address is important (to include) as the reason the contract was pulled is very likely related to activity
					//		at the address. having it above the level of the contract in my opinion makes it easier to see
					//  

					let plannedStoreLocation = storeLocation + "/" + this.time + "/" + dateString + "/" + this.address;
				
					let sources = {};
					
					if((this.state & ContractRequest.REQUEST_SUCCESSFUL) == ContractRequest.REQUEST_SUCCESSFUL) {
					
						sources = this.contractData.SourceCode;
					
					} else {
					
						throw "Error: Contract request is not complete!";
					
					}
					
					sources = sources.sources;
					
					let filesInContract = Object.keys(sources);
					let success = true;
					
					for(let i = 0; i < filesInContract.length; i++) {
					
						success = success & await client.fileManager.writeFile(plannedStoreLocation + "/" + filesInContract[i], sources[filesInContract[i]].content);
					
					}
					
					if(success) {

						this.storedAtLocations.push(plannedStoreLocation);

						this.setState(ContractRequest.LAST_SAVE_SUCCESSFUL | this.state);

					} else {

						// flips bits with an unsigned version of last save then does & with the current state.  
						//
						// this is really overkill, i think i was just bored.
						this.setState((~ContractRequest.LAST_SAVE_SUCCESSFUL >>> 0) & this.state);

					}
					
					return success;
				
				}

				this.setState = function(newState) {


					this.state = newState;

					this.UIUpdatesCallback(this);

				}
				
				
				this.runRequest = async function() {
					
					try {
				
						this.setState(ContractRequest.REQUEST_RUNNING);
						this.attempts++; 
						
						this.lastAPIResult = await requestForContractFromEtherscan(this);
						
						this.apiResults[this.attempts - 1] = this.lastAPIResult;
						
						if(this.lastAPIResult.failedWebRequest) {
						
							this.setState(ContractRequest.REQUEST_FAILED);
						
						} else {
						
							this.lastParsedResult = JSON.parse(this.lastAPIResult.webRequestResult);
							
							if(this.lastParsedResult.status == 1) {
							
								this.contractData = this.lastParsedResult.result[0];
								
								// fix source code format. 
								//
								// if it starts with a bracket, there are multiple source code files
								if(this.contractData.SourceCode[0] == "{") {
								
									this.contractData.SourceCode = JSON.parse(this.contractData.SourceCode.substring(1, this.contractData.SourceCode.length - 1));
								
								// only one source code file. this just makes the format exactly the same as if it had multiple sources.
								} else {
									
									let temp = {};
								
									temp.sources = {};
									
									let tempSourceObj = {};
									tempSourceObj.content = this.contractData.SourceCode;
									
									temp.sources[this.contractData.ContractName + ".sol"] = tempSourceObj;
								
									this.contractData.SourceCode = temp;
								
								}
								
								// fix abi format
								this.contractData.ABI = JSON.parse(this.contractData.ABI);
							
								this.setState(ContractRequest.REQUEST_SUCCESSFUL);
							
							} else {
							
								this.setState(ContractRequest.REQUEST_FAILED);
							
							}
						
						}
						
					} catch(e) {
						
						this.apiResults[this.attempts - 1] = "Unexpected Error: " + e;
						
						this.setState(ContractRequest.REQUEST_FAILED);
					
					}
					
					return this.state;
				
				}
				
				this.getSource = function() {
					
					let source = {};
					
					if((this.state & ContractRequest.REQUEST_SUCCESSFUL) == ContractRequest.REQUEST_SUCCESSFUL) {
					
						source = this.contractData.SourceCode;
					
					} else {
					
						throw "Error: Contract request is not complete!";
					
					}
					
					return source;
				
				}
				
				this.isProxy = function() {
					
					let isProxy = false;
					
					if((this.state & ContractRequest.REQUEST_SUCCESSFUL) == ContractRequest.REQUEST_SUCCESSFUL) {
					
						isProxy = this.contractData.Proxy != 0;
					
					} else {
					
						throw "Error: Contract request is not complete!";
					
					}
					
					return isProxy;
				
				}
				
				this.getAttempts = function() {
				
					return this.attempts;
				
				}
				
				this.getImplementationAddressForProxy = function() {
					
					let impl = "";
					
					if((this.state & ContractRequest.REQUEST_SUCCESSFUL) == ContractRequest.REQUEST_SUCCESSFUL) {
					
						if(this.isProxy()) {
						
							impl = this.contractData.Implementation;
						
						} else {
						
							throw "Error: Contract is not a proxy contract.";
						
						}
					
					} else {
					
						throw "Error: Contract request is not complete!";
					
					}
					
					return impl;
				
				}
			
				
				this.getABI = function() {
					
					let ABI = {};
					
					if((this.state & ContractRequest.REQUEST_SUCCESSFUL) == ContractRequest.REQUEST_SUCCESSFUL) {
					
						ABI = this.contractData.ABI;
					
					} else {
					
						throw "Error: Contract request is not complete!";
					
					}
					
					return ABI;
				
				}
				
			
				this.getStatusDescription = function() {
				
					let description = "";
				
					switch(this.state) {
					
						case ContractRequest.REQUEST_NOT_ATTEMPTED:
							description = "Not started";
							break;
							
						case ContractRequest.REQUEST_RUNNING:
							description = "Running";
							break;
							
						case ContractRequest.REQUEST_SUCCESSFUL:
							description = "Retrieved";
							break;

						case ContractRequest.REQUEST_SUCCESSFUL | ContractRequest.LAST_SAVE_SUCCESSFUL:
							description = "Saved";
							break;	

						case ContractRequest.REQUEST_FAILED:
							description = "Failed";
							break;
					
					}
				
					return description;
				
				}

				return this;
			
			}
			
			// The following two addresses have different structures in return results.
			
			// 0x66017d22b0f8556afdd19fc67041899eb65a21bb
			// 0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413
			function requestForContractFromEtherscan(contractRequestObject) {
			
				let contractAddress = contractRequestObject.address;
				
				let returnResult = {};
				
				returnResult.failedWebRequest = false;
				returnResult.webRequestResult = "";
			
				return new Promise(function(resolve, reject) {
				
					try {
			
						let address = new URL("https://api.etherscan.io/api?module=contract&action=getsourcecode&address=" + contractAddress + "&apikey=YourApiKeyToken"); 
				
						let xmlHttp = new XMLHttpRequest();
						
						xmlHttp.onreadystatechange = function() { 
						
							if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
								
								returnResult.failedWebRequest = false;
								returnResult.webRequestResult = xmlHttp.responseText;
								
								
								resolve(returnResult);
								
							} else if(xmlHttp.readyState == 4) {
								
								returnResult.failedWebRequest = true;
								returnResult.webRequestResult = "Received a web status code that was not 200.";
								
								reject(returnResult);
								
							}
								
						}
						
						xmlHttp.addEventListener('error', function(event) {
							
							returnResult.failedWebRequest = true;
							returnResult.webRequestResult = JSON.stringify(event);
							
							reject(returnResult);
							
						});
						
						xmlHttp.open("GET", address, true); 
						xmlHttp.send(null);
						
					} catch(e) {
						
						returnResult.failedWebRequest = true;
						returnResult.webRequestResult = e;
						
						reject(returnResult);
					
					}
				
				
				});
			
			}

			
			EtherscanRequestsWorker.state = {};
			
			EtherscanRequestsWorker.state.WAITING_FOR_TASK = 0;
			EtherscanRequestsWorker.state.RUNNING_TASK = 1;
			EtherscanRequestsWorker.state.RUNNING_BUT_SLEEPING = 1 << 3;

			function EtherscanRequestsWorker(remixPluginClient, followProxies) {
			
				this.requestsQueue = [];
				this.remixPluginClient = remixPluginClient;
				this.state = 0;
				this.sleepTimeBetweenWebRequests = 5100;
				this.followProxies = followProxies;
				
				this.UIUpdatesCallback = (dataForCallbackUpdates) => {};
				
				this.setUICallback = function(UICallback) {
				
					this.UIUpdatesCallback = UICallback;
				
				}
				
				this.hasQueueJobs = function() {
				
					return this.requestsQueue.length > 0;
				
				}
				
				this.updateState = function(newState) {
				
					this.state = newState;
					this.UIUpdatesCallback(this);
				
				}
				
				this.runQueueJobs = async function() {
				
					this.updateState(EtherscanRequestsWorker.state.RUNNING_TASK);
					
					while(this.requestsQueue.length > 0) {
					
						let currentRequest = this.requestsQueue.pop();
						
						currentRequest.attemptsMade++;
						
						// if it **fails** to run the web request with success and save with success, 
						if(!(await currentRequest.contractRequest.runRequest() == ContractRequest.REQUEST_SUCCESSFUL 
							&& 	await currentRequest.contractRequest.saveSourcesToRemixClient(this.remixPluginClient, currentRequest.saveLocation))) {
							
							// add it back to the queue if the attempts aren't exhausted.
							if(currentRequest.attemptsMade < currentRequest.attemptLimit) {
							
								this.requestsQueue.push(currentRequest);
							
							} else {
							
								// notify attempts are up
							
							}
							
						
						// otherwise, it was successful, so a final check is needed to see if it is a proxy.
						} else if(currentRequest.contractRequest.isProxy() && this.followProxies) {
							
							let implRequest = new ContractRequest(currentRequest.contractRequest.getImplementationAddressForProxy());
							
							// taking the callback function for ui updates from the first. (it's fine if it doesn't have one)
							implRequest.setUICallback(currentRequest.contractRequest.UIUpdatesCallback);
							
							this.addRequest(implRequest, currentRequest.saveLocation, currentRequest.attemptLimit);
						
						}
						
						this.updateState(EtherscanRequestsWorker.state.RUNNING_BUT_SLEEPING);
						await sleep(this.sleepTimeBetweenWebRequests);
						this.updateState(EtherscanRequestsWorker.state.RUNNING_TASK);
						
					}
					
					this.updateState(EtherscanRequestsWorker.state.WAITING_FOR_TASK);
				
				}
				
				this.mainLoop = async function() {
				
					while(true) {
					
						if(this.hasQueueJobs()) {
						
							await this.runQueueJobs();
						
						}
					
						await sleep(200);
					
					}
				
				}
				
				this.start = function() {
				
					return this.mainLoop();
				
				}
				
				this.addRequest = async function(contractRequestObj, saveLocation, attemptLimit) {
				
					let job = {};
					
					job.attemptLimit = attemptLimit;
					job.saveLocation = saveLocation;
					job.contractRequest = contractRequestObj;
					job.attemptsMade = 0;
					
					this.requestsQueue.push(job);
				
				}
			
			
			}



			function HTMLElement(elementID) {
			
				this.elementID = elementID;
				
				this.e = function() {
				
					return document.getElementById(this.elementID);
				
				}
				
				this.setOnUpdate = function(callback) {
				
					return this;
				
				}
			
			
				return this;
			
			}

			let ImportContractUI = {}
						
			ImportContractUI.addNewRequest = function() {
			
				ImportContractUI.plugin.addNewRequest(ImportContractUI.import.contractAddress.e().value, ImportContractUI.requestedImport.requestContractUIUpdatesCallback);
			
			}
			
			
			ImportContractUI.requestedImport = {};
			
			ImportContractUI.requestedImport.htmlInjectionLocation = new HTMLElement("accordionExample");
			
			// not actually going to use this function
			ImportContractUI.requestedImport.injectIntoInjectionLocation = function(inject) {
			
				let current = ImportContractUI.requestedImport.htmlInjectionLocation.e().innerHTML;
			
				ImportContractUI.requestedImport.htmlInjectionLocation.e().innerHTML = inject + current;
			
			}
			
			ImportContractUI.requestedImport.issuedUI = {};
			
			ImportContractUI.requestedImport.requestContractUIUpdatesCallback = function(data) {
			
				if(ImportContractUI.requestedImport.issuedUI[data.address + String(data.time)] == null) {
				
					let newElementID = "importState" + String(Object.keys(ImportContractUI.requestedImport.issuedUI).length);
					
					ImportContractUI.requestedImport.issuedUI[data.address + String(data.time)] = new HTMLElement(newElementID);
					
					let injectLocation = ImportContractUI.requestedImport.htmlInjectionLocation.e();
			
					let injectionTemplate = `<div class="card border border-1 mb-1" id="` + newElementID + `">
												<div class="card-header mb-0" id="` + newElementID +  "heading" + `">
												  <div class="mb-0">
													<button class="btn btn-link btn-sm btn-block text-truncate collapsed" id="` + newElementID +  "buttonHeading" + `" type="button" data-toggle="collapse" data-target="#` + newElementID +  "collapse" + `" aria-expanded="false" aria-controls="` + newElementID +  "collapse" + `">
														` + data.address + `
													</button>
												  </div>
												</div>

												<div id="` + newElementID +  "collapse" + `" class="collapse" aria-labelledby="` + newElementID +  "heading" + `" data-parent="#accordionExample" style="">
													<div class="card-body">

													  	<span id="` + newElementID + "alertInsert" + `"></span>

													  	<div class="row mb-3">
													  		<div class="col-sm-12">
													  			<h6>
													  				Contract
													  			</h6>
													  			<small id="` + newElementID +  "addressC" + `">
													  				0x9814542f4230ab166efef3363a2d85e20d8708c7
													  			</small>
													  		</div>
													  	</div>

														<div class="row mb-0" id="` + newElementID +  "marginChange" + `">
															<div class="col-sm-12">
																<h6>
																	Status
																</h6>
																<small id="` + newElementID +  "status" + `">
																	Not yet requested
																</small>
															</div>
														</div>

														<span id="` + newElementID +  "storageInject" + `">



														</span>

													</div>
												</div>
											</div>`; 

					injectLocation.innerHTML = injectionTemplate + injectLocation.innerHTML;
				} 
				
				let current = ImportContractUI.requestedImport.issuedUI[data.address + String(data.time)];
				
				let heading = document.getElementById(current.elementID + "buttonHeading");
				let status = document.getElementById(current.elementID + "status");
				let addressC = document.getElementById(current.elementID + "addressC");
				let alertInsert = document.getElementById(current.elementID + "alertInsert");
				let storageInject = document.getElementById(current.elementID +  "storageInject");
				let marginChange = document.getElementById(current.elementID + "marginChange");

				heading.innerHTML = data.address;
				status.innerHTML = data.getStatusDescription();

				if(data.storedAtLocations.length > 0) {

					let storageInjection = `	<div class="row">
													<div class="col-sm-12">
														<h6 class="mb-3">
															Storage Location
														</h6>
														<small>  
															<div class="col-sm-12 mb-0 bg-dark pt-2 pb-2 border border-1 rounded" id="` + current.elementID +  "storage" + `">
																/etherscan/current_job/0x9814542f4230ab166efef3363a2d85e20d8708c7
															</div>
														</small>
													</div>
												</div>`;

					marginChange.classList = "row mb-3";
					storageInject.innerHTML = storageInjection;

					let storage = document.getElementById(current.elementID + "storage");

					storage.value = data.storedAtLocations.length > 1 ? JSON.stringify(data.storedAtLocations) : data.storedAtLocations[0];
				}

				addressC.innerHTML = data.address;
			
			}
			
			ImportEtherscanContractPlugin.networks = {};
			
			ImportEtherscanContractPlugin.networks.ETHEREUM_MAINNET = 0;
			
			function ImportEtherscanContractPlugin(remixClient, defaultNetwork, defaultAPIKey, defaultStorageLocation, defaultRetryAttempts, workerUICallback) {

				this.network = defaultNetwork;
				this.APIKey = defaultAPIKey;
				this.storageLocation = defaultStorageLocation;
				this.retryAttempts = defaultRetryAttempts;
				this.workerUICallback = workerUICallback;
				
				if(this.workerUICallback == null) 
					this.workerUICallback = () => {};
				
				this.worker = new EtherscanRequestsWorker(client, true);
				
				this.addNewRequest = function(requestAddress, callbackForUI) {
				
					this.addNewRequestWithoutDefaults(requestAddress, this.storageLocation, this.retryAttempts, callbackForUI);
				
				}
				
				// this is for internal requests and requests made outside of the UI that want to override the default settings. 
				this.addNewRequestWithoutDefaults = function(requestAddress, storageLocation, retryAttempts, callbackForUI) {
				
					if(callbackForUI == null) {
					
						callbackForUI = () => {};
					
					}
				
					let contractToRequest = new ContractRequest(requestAddress);
					
					contractToRequest.setUICallback(callbackForUI);
				
					this.worker.addRequest(contractToRequest, storageLocation, retryAttempts);
				
				}
				
				this.worker.setUICallback(this.workerUICallback);
				this.worker.start();
			
				return this;
			
			}
			
			
			ImportContractUI.import = {};
			
			ImportContractUI.import.contractAddress = new HTMLElement("importContractAddress");
			ImportContractUI.import.importTab = new HTMLElement("importContractImportTab");
			ImportContractUI.import.settingsTab = new HTMLElement("importContractSettingsTab");
			ImportContractUI.import.cardBodyContent = new HTMLElement("importContractCardBodyContent");
			
			ImportContractUI.import.contractAPIKey =  new HTMLElement("importContractApiKey");
			ImportContractUI.import.contractStorageLocation = new HTMLElement("importContractStorageLocation");
			ImportContractUI.import.contractRetryAttempts = new HTMLElement("importContractRetryAttempts");
			
			
			ImportContractUI.import.setActive = function(tabID) {
					
				let activeTabClasses = "nav-link bg-secondary active btn-sm";
				let inactiveTabClasses = "nav-link btn-sm";
				
				let tabs = [ImportContractUI.import.importTab, ImportContractUI.import.settingsTab];
				
				
				let inject1 = "	<p class=\"mb-2\"><small>Enter the address of a contract on Etherscan to attempt to import it into Remix</small></p>      <div class=\"form-group mb-2 mt-0\">    <label for=\"importContractSelectNetwork\">Network</label>    <select class=\"form-control\" id=\"importContractSelectNetwork\" disabled>      <option>Ethereum Mainnet</option>      <option>2</option>      <option>3</option>      <option>4</option>      <option>5</option>    </select>  </div>  <div class=\"form-group\">    <label for=\"importContractAddress\">Contract Address</label>    <input type=\"text\" class=\"form-control\" id=\"importContractAddress\" placeholder=\"0x.....\">  </div>    <button type=\"submit\" class=\"btn btn-primary btn-block btn-sm\" onclick=\"ImportContractUI.addNewRequest()\">Request</button>      ";
				let inject2 = "<div class=\"form-group\">    <label for=\"importContractApiKey\">Etherscan API Key</label>    <input type=\"text\" class=\"form-control\" id=\"importContractApiKey\" placeholder=\"Optional: Etherscan API Key\">  </div>      <div class=\"form-group\">    <label for=\"importContractStorageLocation\">Storage Location</label>    <input type=\"text\" class=\"form-control\" id=\"importContractStorageLocation\" placeholder=\"/etherscan/contracts\" value=\"/etherscan/contracts\">  </div>        <div class=\"form-group\">    <label for=\"importContractRetryAttempts\">Retry Attempts on Failure</label>    <input type=\"text\" class=\"form-control\" id=\"importContractRetryAttempts\" placeholder=\"3\" value=\"3\">  </div>"
				
				let injections = [inject1, inject2]
				
				for(let i = 0; i < tabs.length; i++) {
				
					tabs[i].e().classList.value = inactiveTabClasses;
				
				}
				
				tabs[tabID].e().classList.value = activeTabClasses;
				
				ImportContractUI.import.cardBodyContent.e().innerHTML = injections[tabID];
			
			}
			
			
			let client = plugin_iframe.createClient();
			
			// client, network, apiKey, storageLocation, retryAttemptsOnFailure
			ImportContractUI.plugin = new ImportEtherscanContractPlugin(client, ImportEtherscanContractPlugin.networks.ETHEREUM_MAINNET, "", "/etherscan/contracts", 3);
			

		</script>



	<div class="container">
	<div class="card mb-3 mt-2"><div class="card-body">
	

			<div class="row mb-3"><div class="col-sm-12">
		<h6>Status</h6> <div class="d-flex align-items-center">  <small> Running</small>  	<div class="spinner-border ms-auto ml-3"  style="width: 1.2rem; height: 1.2rem;" role="status" aria-hidden="true"></div>	</div>
		</div></div>
		
				<div class="row"><div class="col-sm-12">
		<h6>Task </h6>  <small> Waiting on API cooldown</small>  		</div>
		


		
		
		</div></div>
	
	
	





</div>
	
	<!---
<h6 class="mb-3 ml-1 mt-1">Import a Contract</h6>
<div class="card mb-3">
  <div class="card-header">
  
  
    <ul class="nav nav-pills card-header-pills nav-fill">
      <li class="nav-item">
        <a class="nav-link btn-sm" href="#" id="importContractImportTab">Import</a>
      </li>
      <li class="nav-item">
        <a class="nav-link bg-secondary active btn-sm" href="#" id="importContractSettingsTab">Settings</a>
      </li>
    </ul>
  </div>
  <div class="card-body" id="importContractCardBodyContent">
  
<div class="form-group">
    <label for="importContractApiKey">Etherscan API Key</label>
    <input type="text" class="form-control" id="importContractApiKey" placeholder="Optional: Etherscan API Key">
  </div>
  
  
  <div class="form-group">
    <label for="importContractStorageLocation">Storage Location</label>
    <input type="text" class="form-control" id="importContractStorageLocation" placeholder="/etherscan/contracts" value="/etherscan/contracts">
  </div>
  
    
  <div class="form-group">
    <label for="importContractRetryAttempts">Retry Attempts on Failure</label>
    <input type="text" class="form-control" id="importContractRetryAttempts" placeholder="3" value="3">
  </div>

  </div>
  
  
</div>--->


	
	
	
	

<h6 class="mb-3 ml-1 mt-1">Import a Contract</h6>
<div class="card mb-3">
  <div class="card-header">
  
  
    <ul class="nav nav-pills card-header-pills nav-fill">
      <li class="nav-item">
        <a class="nav-link bg-secondary active btn-sm" href="#" onclick="event.preventDefault(); ImportContractUI.import.setActive(0)" id="importContractImportTab">Import</a>
      </li>
      <li class="nav-item">
        <a class="nav-link btn-sm" onclick="event.preventDefault(); ImportContractUI.import.setActive(1)" href="#" id="importContractSettingsTab">Settings</a>
      </li>
    </ul>
  </div>
  <div class="card-body" id="importContractCardBodyContent">

	<p class="mb-2"><small>Enter the address of a contract on Etherscan to attempt to import it into Remix</small></p>
  
    <div class="form-group mb-2 mt-0">
    <label for="importContractSelectNetwork">Network</label>
    <select class="form-control" id="importContractSelectNetwork" disabled>
      <option>Ethereum Mainnet</option>
      <option>2</option>
      <option>3</option>
      <option>4</option>
      <option>5</option>
    </select>
  </div>
  
<div class="form-group">
    <label for="importContractAddress">Contract Address</label>
    <input type="text" class="form-control" id="importContractAddress" placeholder="0x.....">
  </div>
  
  <button type="submit" class="btn btn-primary btn-block btn-sm" onclick="ImportContractUI.addNewRequest()">Request</button>
  
  
  
  
  </div>
  
  
</div>




<h6 class="mb-3 ml-1 mt-1">Contracts for Import</h6>
	
		<div class="accordion" id="accordionExample">
  <div class="card border border-1 mb-1">
    <div class="card-header mb-0" id="headingOne">
      <div class="mb-0">
        <button class="btn btn-link btn-sm btn-block text-truncate" type="button" data-toggle="collapse" data-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
        #0001: 0x9814542f4230ab166efef3363a2d85e20d8708c7
        </button>
      </div>
    </div>

    <div id="collapseOne" class="collapse show" aria-labelledby="headingOne" data-parent="#accordionExample">
      <div class="card-body">
      <div class="row mb-3"><div class="col-sm-12"><h6>Contract</h6><small>0x9814542f4230ab166efef3363a2d85e20d8708c7</small></div></div>
		<div class="row mb-3"><div class="col-sm-12">
		<h6>Status</h6><small>Not yet requested</small>
		</div></div>
				<div class="row"><div class="col-sm-12">
		<h6 class="mb-3">Storage Location</h6><small>  
		
		<textarea class="form-control" id="exampleFormControlTextarea1" rows="3" disabled>/etherscan/current_job/0x9814542f4230ab166efef3363a2d85e20d8708c7</textarea></small>
		</div></div>
		
		
		
	
		</div>
    </div>
  </div>
  
    <div class="card border border-1 mb-1">
    <div class="card-header mb-0" id="headingOne">
      <div class="mb-0">
        <button class="btn btn-link btn-sm btn-block text-truncate" type="button" data-toggle="collapse" data-target="#collapseOne2" aria-expanded="false" aria-controls="collapseOne2">
        0x9814542f4230ab166efef3363a2d85e20d8708c7
        </button>
      </div>
    </div>

    <div id="collapseOne2" class="collapse" aria-labelledby="headingOne" data-parent="#accordionExample">
      <div class="card-body">
	  <div class="alert alert-success" role="alert">
  <small>This contract was successfully imported!</small>
</div>
      <div class="row mb-3"><div class="col-sm-12"><h6>Contract</h6><small>0x9814542f4230ab166efef3363a2d85e20d8708c7</small></div></div>
		<div class="row"><div class="col-sm-12">
		<h6>Status</h6><small>Not yet requested</small>
		</div></div>
		
		
	
		</div>
    </div>
  </div>
    
    <div class="card border border-1 mb-3">
    <div class="card-header mb-0" id="headingOne">
      <div class="mb-0">
        <button class="btn btn-link btn-sm btn-block text-truncate" type="button" data-toggle="collapse" data-target="#collapseOne3" aria-expanded="false" aria-controls="collapseOne3">
        0x9814542f4230ab166efef3363a2d85e20d8708c7
        </button>
      </div>
    </div>

    <div id="collapseOne3" class="collapse" aria-labelledby="headingOne" data-parent="#accordionExample">
      <div class="card-body">
	  
	  <div class="alert alert-danger" role="alert">
	  <small>This contract's source code was not available on Etherscan</small>
</div>
	  
	  
      <div class="row mb-3"><div class="col-sm-12"><h6>Contract</h6><small>0x9814542f4230ab166efef3363a2d85e20d8708c7</small></div></div>
		<div class="row mb-3"><div class="col-sm-12">
		<h6>Status</h6><small>Not yet requested</small>
		</div></div>
		
		<button class="btn btn-sm btn-danger btn-block">Retry</button>
		
		
	
		</div>
    </div>
  </div>
  
</div>





		</div>
		
		<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
	</body>
</html>