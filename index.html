<!DOCTYPE html>
<html>
	<head>
		<!--- 

			bootstrap css is auto injected by the parent frame

			<link id="cssChanges" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"> 

		---->
		<meta charset="utf-8" />
		<title>Import for Etherscan</title>
	</head>
	<body>

		<script src="./js/remix/plugin/plugin_iframe.js"></script>
		<script>

			function sleep(ms) {

				return new Promise(resolve => setTimeout(resolve, ms));

			}

			ContractRequest.REQUEST_NOT_ATTEMPTED = 0 << 0;
			ContractRequest.REQUEST_RUNNING = 1 << 0;
			ContractRequest.REQUEST_SUCCESSFUL = 1 << 1;
			ContractRequest.REQUEST_FAILED = 1 << 2;
			ContractRequest.LAST_SAVE_SUCCESSFUL = 1 << 3;
			ContractRequest.NOTIFIED_COMPLETE_SUCCESS = 1 << 4;
			ContractRequest.NOTIFIED_COMPLETE_FAILURE = 1 << 5;

			function ContractRequest(address) {
				
				this.state = ContractRequest.REQUEST_NOT_ATTEMPTED;
				this.address = address;
				this.lastAPIResult = "";
				this.customStateText = "";

				this.saveFailures = [];
				this.requestFailures = [];
				
				this.lastParsedResult = {};
				this.contractData = {};

				// i didn't want to set the storage location on creation, because someone might want to make a 
				// request + save then save again somewhere else. these are just strings with the location of successful saves
				this.storedAtLocations = [];

				
				// if someone pulls the contract again after modifying a pulled contract,
				// it will overwrite their work. saving a time is unique enough to prevent
				// this from happening, and is also useful when looking directly at contract addresses
				this.time = new Date().getTime();
				
				
				this.UIUpdatesCallback = (dataForCallbackUpdates) => {};
				
				this.setUICallback = function(UICallback) {
				
					this.UIUpdatesCallback = UICallback;

					this.UIUpdatesCallback(this);
				
				}
				
				this.failSave = function(reason) {

					this.saveFailures.push(reason);
					this.setState((~ContractRequest.LAST_SAVE_SUCCESSFUL >>> 0) & this.state);

					return false;

				}

				this.failRequest = function(reason) {

					this.setState(ContractRequest.REQUEST_FAILED);
					this.requestFailures.push(reason);

					return this.state;

				}

				this.saveSourcesToRemixClient = async function(remixClient, storeLocation) {


					let dateString = String(new Date(Number(this.time)).toLocaleString()).replaceAll(":", "_").replaceAll("/", "-").replaceAll(",", "");

					// in the future, i might add the ability to customize this. 
					//
					// the current format is { unixTime } / { formattedLocaleTime } / { address } 
					// 
					// the argument for this format is below
					//
					// 	leading with the initiated DateTime unix time
					//		- helps with confusion related to address sort - "i remember requesting this one before that one, 
					//			but don't remember what address that was"
					//  	- automatically orders all saved contracts in this folder with a unique natural ID. this saves
					//			someone who modifies a contract from accidentally writing over it if they request
					//			a new version for comparison. 
					//		- it forces a correct sort by creation date
					//
					//	followed by the actual formatted date
					//		- it makes the order immediately obvious, and is helpful when it's been a while since reviewing a contract
					//		- it prevents someone from confusing where the requested contract will be stored. ex. if they perceived
					// 			the unix time as an id, the order might appear { id } / { address } / { time }. so they might believe
					//			that future requests could end up with a different time under the address, which wouldn't be so bad,
					//			however, i didn't want to do the small amount of work to make this reality when i like the this format more
					//	
					// 	and finally, followed by the address
					//	- the address is important (to include) as the reason the contract was pulled is very likely related to activity
					//		at the address. having it above the level of the contract in my opinion makes it easier to see
					//  

					let plannedStoreLocation = storeLocation + "/" + this.time + "/" + dateString + "/" + this.address;
				
					let sources = {};
					
					if((this.state & ContractRequest.REQUEST_SUCCESSFUL) == ContractRequest.REQUEST_SUCCESSFUL) {
					
						sources = this.contractData.SourceCode;
					
					} else {
					
						this.failSave("Attempted to save before requesting contract from Etherscan.");

						throw "Error: Contract request is not complete!";
					
					}
					
					let filesInContract = []; 
					let success = true;

					try {

						sources = sources.sources;
						filesInContract = Object.keys(sources);

					} catch(e) {

						return this.failSave("Unexpected parsed format. (1)");

					}

					try {
					
						for(let i = 0; i < filesInContract.length && success; i++) {

							let fileName = "";
							let sourceFileContent = "";

							try {

								fileName = filesInContract[i]
								sourceFileContent = sources[filesInContract[i]].content;

							} catch(e) {

								return this.failSave("Unexpected parsed format. (2)");

							}
						
							success = success & await client.fileManager.writeFile(plannedStoreLocation + "/" + fileName, sourceFileContent);
						
						}

					} catch(e) {

						return this.failSave(e);

					}
					
					if(success) {

						this.storedAtLocations.push(plannedStoreLocation);

						this.setState(ContractRequest.LAST_SAVE_SUCCESSFUL | this.state);

					} else {

						return this.failSave("Remix didn't provide a reason for failing to save.");

					}
					
					return success;
				
				}

				this.setState = function(newState) {

					this.state = newState;

					this.UIUpdatesCallback(this);

				}
				



				
				this.runRequest = async function() {
					
					try {
				
						this.setState(ContractRequest.REQUEST_RUNNING);
						
						this.lastAPIResult = await requestForContractFromEtherscan(this);
						
						if(this.lastAPIResult.failedWebRequest) {
						
							return this.failRequest("Web request failed: " + this.lastAPIResult.webRequestResult);
						
						} else {
						
							try {

								this.lastParsedResult = JSON.parse(this.lastAPIResult.webRequestResult);
								
								if(this.lastParsedResult.status == 1) {
								
									this.contractData = this.lastParsedResult.result[0];
									
									// fix source code format. 
									//
									// if it starts with a bracket, there are multiple source code files
									if(this.contractData.SourceCode[0] == "{") {
									
										this.contractData.SourceCode = JSON.parse(this.contractData.SourceCode.substring(1, this.contractData.SourceCode.length - 1));
									
									// only one source code file. this just makes the format exactly the same as if it had multiple sources.
									} else {
										
										let temp = {};
									
										temp.sources = {};
										
										let tempSourceObj = {};
										tempSourceObj.content = this.contractData.SourceCode;
										
										temp.sources[this.contractData.ContractName + ".sol"] = tempSourceObj;
									
										this.contractData.SourceCode = temp;
									
									}
									
									// fix abi format
									this.contractData.ABI = JSON.parse(this.contractData.ABI);
								
									this.setState(ContractRequest.REQUEST_SUCCESSFUL);
								
								} else {
								
									return this.failRequest("API timeout or contract doesn't exist");
								
								}

							} catch(e) {

								return this.failRequest("Parse error");

							}
						
						}
						
					} catch(e) {
						
						return this.failRequest("Unexpected Error: " + e);
					
					}
					
					return this.state;
				
				}
				
				this.getSource = function() {
					
					let source = {};
					
					if((this.state & ContractRequest.REQUEST_SUCCESSFUL) == ContractRequest.REQUEST_SUCCESSFUL) {
					
						source = this.contractData.SourceCode;
					
					} else {
					
						throw "Error: Contract request is not complete!";
					
					}
					
					return source;
				
				}
				
				this.isProxy = function() {
					
					let isProxy = false;
					
					if((this.state & ContractRequest.REQUEST_SUCCESSFUL) == ContractRequest.REQUEST_SUCCESSFUL) {
					
						isProxy = this.contractData.Proxy != 0;
					
					} else {
					
						throw "Error: Contract request is not complete!";
					
					}
					
					return isProxy;
				
				}
				
				this.getImplementationAddressForProxy = function() {
					
					let impl = "";
					
					if((this.state & ContractRequest.REQUEST_SUCCESSFUL) == ContractRequest.REQUEST_SUCCESSFUL) {
					
						if(this.isProxy()) {
						
							impl = this.contractData.Implementation;
						
						} else {
						
							throw "Error: Contract is not a proxy contract.";
						
						}
					
					} else {
					
						throw "Error: Contract request is not complete!";
					
					}
					
					return impl;
				
				}
			
				
				this.getABI = function() {
					
					let ABI = {};
					
					if((this.state & ContractRequest.REQUEST_SUCCESSFUL) == ContractRequest.REQUEST_SUCCESSFUL) {
					
						ABI = this.contractData.ABI;
					
					} else {
					
						throw "Error: Contract request is not complete!";
					
					}
					
					return ABI;
				
				}
				
			
				this.getStatusDescription = function() {
				
					let description = "";
				
					switch(this.state) {
					
						case ContractRequest.REQUEST_NOT_ATTEMPTED:
							description = "Not yet started";
							break;
							
						case ContractRequest.REQUEST_RUNNING:
							description = "Requesting (still processing)";
							break;
							
						case ContractRequest.REQUEST_SUCCESSFUL:
							description = "Retrieved (attempting to save)";
							break;

						case ContractRequest.REQUEST_SUCCESSFUL | ContractRequest.LAST_SAVE_SUCCESSFUL:
							description = "Saved (still processing)";
							break;	

						case ContractRequest.REQUEST_FAILED:
							description = "Failed (still retrying)";
							break;

						case ContractRequest.NOTIFIED_COMPLETE_FAILURE:
							description = "Failed";
							break;

						case ContractRequest.NOTIFIED_COMPLETE_SUCCESS:
							description = "Complete";
							break;
					
					}
				
					return description;
				
				}

				return this;
			
			}
			
			// The following two addresses have different structures in return results.
			
			// 0x66017d22b0f8556afdd19fc67041899eb65a21bb
			// 0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413
			function requestForContractFromEtherscan(contractRequestObject) {
			
				let contractAddress = contractRequestObject.address;
				
				let returnResult = {};
				
				returnResult.failedWebRequest = false;
				returnResult.webRequestResult = "";
			
				return new Promise(function(resolve, reject) {
				
					try {
			
						let address = new URL("https://api.etherscan.io/api?module=contract&action=getsourcecode&address=" + contractAddress + "&apikey=YourApiKeyToken"); 
				
						let xmlHttp = new XMLHttpRequest();
						
						xmlHttp.onreadystatechange = function() { 
						
							if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
								
								returnResult.failedWebRequest = false;
								returnResult.webRequestResult = xmlHttp.responseText;
								
								
								resolve(returnResult);
								
							} else if(xmlHttp.readyState == 4) {
								
								returnResult.failedWebRequest = true;
								returnResult.webRequestResult = "Received a web status code that was not 200. Code: " + String(xmlHttp.status);
								
								resolve(returnResult);
								
							}
								
						}
						
						xmlHttp.addEventListener('error', function(event) {
							
							returnResult.failedWebRequest = true;
							returnResult.webRequestResult = JSON.stringify(event);
							
							resolve(returnResult);
							
						});
						
						xmlHttp.open("GET", address, true); 
						xmlHttp.send(null);
						
					} catch(e) {
						
						returnResult.failedWebRequest = true;
						returnResult.webRequestResult = e;
						
						resolve(returnResult);
					
					}
				
				
				});
			
			}

			
			EtherscanRequestsWorker.state = {};
			
			EtherscanRequestsWorker.state.WAITING_FOR_TASK = 0;
			EtherscanRequestsWorker.state.RUNNING_TASK = 1;
			EtherscanRequestsWorker.state.RUNNING_BUT_SLEEPING = 1 << 3;

			function EtherscanRequestsWorker(remixPluginClient, followProxies) {
			
				this.requestsQueue = [];
				this.remixPluginClient = remixPluginClient;
				this.state = 0;
				this.sleepTimeBetweenWebRequests = 5100;
				this.followProxies = followProxies;
				
				this.UIUpdatesCallback = (dataForCallbackUpdates) => {};
				
				this.setUICallback = function(UICallback) {
				
					this.UIUpdatesCallback = UICallback;
				
				}
				
				this.hasQueueJobs = function() {
				
					return this.requestsQueue.length > 0;
				
				}
				
				this.updateState = function(newState) {
				
					this.state = newState;
					this.UIUpdatesCallback(this);
				
				}
				
				this.runQueueJobs = async function() {
				
					this.updateState(EtherscanRequestsWorker.state.RUNNING_TASK);
					
					while(this.requestsQueue.length > 0) {
					
						let currentRequest = this.requestsQueue.pop();
						
						currentRequest.attemptsMade++;

						let requestSuccess = false;
						let saveSuccess = false;

						let lastSavedException = null;

						try { 

							requestSuccess = await currentRequest.contractRequest.runRequest() == ContractRequest.REQUEST_SUCCESSFUL;

						} catch(e) {

							lastSavedException = e;

						}

						try { 

							saveSuccess = requestSuccess ? await currentRequest.contractRequest.saveSourcesToRemixClient(this.remixPluginClient, currentRequest.saveLocation) : false;

						} catch(e) {

							lastSavedException = e;

						}

						if(!(requestSuccess && saveSuccess)) {

							// add it back to the queue if the attempts aren't exhausted.
							if(currentRequest.attemptsMade < currentRequest.attemptLimit) {
							
								this.requestsQueue.push(currentRequest);
							
							} else {

								currentRequest.contractRequest.setState(ContractRequest.NOTIFIED_COMPLETE_FAILURE);
							
							}

						} 

						if(requestSuccess && saveSuccess) {

							if(currentRequest.contractRequest.isProxy() && this.followProxies) {
							
								let implRequest = new ContractRequest(currentRequest.contractRequest.getImplementationAddressForProxy());
								
								// taking the callback function for ui updates from the first. (it's fine if it doesn't have one)
								implRequest.setUICallback(currentRequest.contractRequest.UIUpdatesCallback);
								
								this.addRequest(implRequest, currentRequest.saveLocation, currentRequest.attemptLimit);
							
							}

							currentRequest.contractRequest.setState(ContractRequest.NOTIFIED_COMPLETE_SUCCESS);

						}
						
						
						this.updateState(EtherscanRequestsWorker.state.RUNNING_BUT_SLEEPING);
						await sleep(this.sleepTimeBetweenWebRequests);
						this.updateState(EtherscanRequestsWorker.state.RUNNING_TASK);
						
					}
					
					this.updateState(EtherscanRequestsWorker.state.WAITING_FOR_TASK);
				
				}
				
				this.mainLoop = async function() {
				
					while(true) {
					
						if(this.hasQueueJobs()) {
						
							await this.runQueueJobs();
						
						}
					
						await sleep(200);
					
					}
				
				}
				
				this.start = function() {
				
					return this.mainLoop();
				
				}
				
				this.addRequest = async function(contractRequestObj, saveLocation, attemptLimit) {
				
					let job = {};
					
					job.attemptLimit = attemptLimit;
					job.saveLocation = saveLocation;
					job.contractRequest = contractRequestObj;
					job.attemptsMade = 0;
					
					this.requestsQueue.push(job);
				
				}
			
			
			}



			function HTMLElement(elementID) {
			
				this.elementID = elementID;
				
				this.e = function() {
				
					return document.getElementById(this.elementID);
				
				}
				
				this.setOnUpdate = function(callback) {
				
					return this;
				
				}
			
			
				return this;
			
			}

			let ImportContractUI = {}
						
			ImportContractUI.addNewRequest = async function() {

				let inputVal = ImportContractUI.import.contractAddress.e().value;

				// replace spaces, and split by comma (for multiple addresses at once)
				inputVal = inputVal.replaceAll(" ", "").split(",");

				for(requestedContract of inputVal) {

					ImportContractUI.plugin.addNewRequest(requestedContract, ImportContractUI.requestedImport.requestContractUIUpdatesCallback);

					// this is somewhat of a hack to guarantee none accidentally end up in the same folder
					// id is something like { unix_timestamp } / { date } / { address }
					// (sleep for 1 millisecond)
					await sleep(1);

				}
			
			}
			
			
			ImportContractUI.requestedImport = {};
			
			ImportContractUI.requestedImport.htmlInjectionLocation = new HTMLElement("accordionExample");
			
			// not actually going to use this function
			ImportContractUI.requestedImport.injectIntoInjectionLocation = function(inject) {
			
				let current = ImportContractUI.requestedImport.htmlInjectionLocation.e().innerHTML;
			
				ImportContractUI.requestedImport.htmlInjectionLocation.e().innerHTML = inject + current;
			
			}
			
			ImportContractUI.requestedImport.issuedUI = {};
			
			ImportContractUI.requestedImport.requestContractUIUpdatesCallback = function(data) {
			
				if(ImportContractUI.requestedImport.issuedUI[data.address + String(data.time)] == null) {
				
					let newElementID = "importState" + String(Object.keys(ImportContractUI.requestedImport.issuedUI).length);
					
					ImportContractUI.requestedImport.issuedUI[data.address + String(data.time)] = new HTMLElement(newElementID);
					
					let injectLocation = ImportContractUI.requestedImport.htmlInjectionLocation.e();
			
					let injectionTemplate = `<div class="card border border-1 mb-1" id="` + newElementID + `">
												<div class="card-header mb-0" id="` + newElementID +  "heading" + `">
												  <div class="mb-0">
													<button class="btn btn-link btn-sm btn-block text-truncate collapsed" id="` + newElementID +  "buttonHeading" + `" type="button" data-toggle="collapse" data-target="#` + newElementID +  "collapse" + `" aria-expanded="false" aria-controls="` + newElementID +  "collapse" + `">
														` + data.address + `
													</button>
												  </div>
												</div>

												<div id="` + newElementID +  "collapse" + `" class="collapse" aria-labelledby="` + newElementID +  "heading" + `" data-parent="#accordionExample" style="">
													<div class="card-body">

													  	<span id="` + newElementID + "alertInsert" + `"></span>

													  	<div class="row mb-3">
													  		<div class="col-sm-12">
													  			<h6>
													  				Contract
													  			</h6>
													  			<small id="` + newElementID +  "addressC" + `">
													  				0x9814542f4230ab166efef3363a2d85e20d8708c7
													  			</small>
													  		</div>
													  	</div>

														<div class="row mb-0" id="` + newElementID +  "marginChange" + `">
															<div class="col-sm-12">
																<h6>
																	Status
																</h6>
																<small id="` + newElementID +  "status" + `">
																	Not yet requested
																</small>
															</div>
														</div>

														<span id="` + newElementID +  "storageInject" + `">



														</span>

													</div>
												</div>
											</div>`; 

					injectLocation.innerHTML = injectionTemplate + injectLocation.innerHTML;
				} 
				
				let current = ImportContractUI.requestedImport.issuedUI[data.address + String(data.time)];
				
				let heading = document.getElementById(current.elementID + "buttonHeading");
				let status = document.getElementById(current.elementID + "status");
				let addressC = document.getElementById(current.elementID + "addressC");
				let alertInsert = document.getElementById(current.elementID + "alertInsert");
				let storageInject = document.getElementById(current.elementID +  "storageInject");
				let marginChange = document.getElementById(current.elementID + "marginChange");
				let card = document.getElementById(current.elementID);

				let defaultCardClasslist = "card border border-1 mb-1"
				let cardClasslistAddition = "";

				if(data.state != ContractRequest.REQUEST_NOT_ATTEMPTED) {

					cardClasslistAddition = "border-warning";

				}

				heading.innerHTML = data.address;
				status.innerHTML = data.getStatusDescription();

				if(data.storedAtLocations.length > 0) {

					let storageInjection = `	<div class="row">
													<div class="col-sm-12">
														<h6 class="mb-3">
															Storage Location
														</h6>
														<small>  
															<div class="col-sm-12 mb-0 bg-dark pt-2 pb-2 border border-1 rounded" id="` + current.elementID +  "storage" + `">
																/etherscan/current_job/0x9814542f4230ab166efef3363a2d85e20d8708c7
															</div>
														</small>
													</div>
												</div>`;

					marginChange.classList = "row mb-3";
					storageInject.innerHTML = storageInjection;

					let storage = document.getElementById(current.elementID + "storage");

					storage.innerHTML = data.storedAtLocations.length > 1 ? JSON.stringify(data.storedAtLocations) : data.storedAtLocations[0];
				}

				let shouldInsertAlert = data.state == ContractRequest.NOTIFIED_COMPLETE_FAILURE || data.state == ContractRequest.NOTIFIED_COMPLETE_SUCCESS;
				let isStateFail = data.state == ContractRequest.NOTIFIED_COMPLETE_FAILURE;

				if(shouldInsertAlert) {

					// alert also signals that it is done, so the card border should be changed
					cardClasslistAddition = "border-success"

					let alertType = "success";
					let alertMessage = "This contract was successfully imported!";

					if(isStateFail) {

						cardClasslistAddition = "border-danger"
						alertType = "danger";
						alertMessage = "Failed: " + String(data.saveFailures.length > 0 ? data.saveFailures[data.saveFailures.length - 1] : data.requestFailures[data.requestFailures.length - 1]);

					}

					let alertInsertInjection = `<div class="alert alert-`+ alertType +`" role="alert">
													  <small>`+ alertMessage +`</small>
												</div>`


					alertInsert.innerHTML = alertInsertInjection;


				}

				card.classList = defaultCardClasslist + " " + cardClasslistAddition;

				addressC.innerHTML = data.address;

			
			}
			
			ImportEtherscanContractPlugin.networks = {};
			
			ImportEtherscanContractPlugin.networks.ETHEREUM_MAINNET = 0;
			
			function ImportEtherscanContractPlugin(remixClient, defaultNetwork, defaultAPIKey, defaultStorageLocation, defaultRetryAttempts, workerUICallback) {

				this.network = defaultNetwork;
				this.APIKey = defaultAPIKey;
				this.storageLocation = defaultStorageLocation;
				this.retryAttempts = defaultRetryAttempts;
				this.workerUICallback = workerUICallback;
				
				if(this.workerUICallback == null) 
					this.workerUICallback = () => {};
				
				this.worker = new EtherscanRequestsWorker(client, true);
				
				this.addNewRequest = function(requestAddress, callbackForUI) {
				
					this.addNewRequestWithoutDefaults(requestAddress, this.storageLocation, this.retryAttempts, callbackForUI);
				
				}
				
				// this is for internal requests and requests made outside of the UI that want to override the default settings. 
				this.addNewRequestWithoutDefaults = function(requestAddress, storageLocation, retryAttempts, callbackForUI) {
				
					if(callbackForUI == null) {
					
						callbackForUI = () => {};
					
					}
				
					let contractToRequest = new ContractRequest(requestAddress);
					
					contractToRequest.setUICallback(callbackForUI);
				
					this.worker.addRequest(contractToRequest, storageLocation, retryAttempts);
				
				}
				
				this.worker.setUICallback(this.workerUICallback);
				this.worker.start();
			
				return this;
			
			}
			
			
			ImportContractUI.import = {};
			
			ImportContractUI.import.contractAddress = new HTMLElement("importContractAddress");
			ImportContractUI.import.importTab = new HTMLElement("importContractImportTab");
			ImportContractUI.import.settingsTab = new HTMLElement("importContractSettingsTab");
			ImportContractUI.import.cardBodyContent = new HTMLElement("importContractCardBodyContent");
			
			ImportContractUI.import.contractAPIKey =  new HTMLElement("importContractApiKey");
			ImportContractUI.import.contractStorageLocation = new HTMLElement("importContractStorageLocation");
			ImportContractUI.import.contractRetryAttempts = new HTMLElement("importContractRetryAttempts");
			
			
			ImportContractUI.import.setActive = function(tabID) {
					
				let activeTabClasses = "nav-link bg-secondary active btn-sm";
				let inactiveTabClasses = "nav-link btn-sm";
				
				let tabs = [ImportContractUI.import.importTab, ImportContractUI.import.settingsTab];
				

				let inject1 = `<p class="mb-2">

									<small>
										Enter the address of a contract on Etherscan to attempt to import it into Remix
									</small>

								</p>      

								<div class="form-group mb-2 mt-0">    

									<label for="importContractSelectNetwork">

										Network

									</label>    

									<select class="form-control" id="importContractSelectNetwork" disabled>     

										<option>
											Ethereum Mainnet
										</option>      
										<option>
											2
										</option>      
										<option>
											3
										</option>      
										<option>
											4
										</option>      
										<option>
											5
										</option>    

									</select>  

								</div>  

								<div class="form-group">    

									<label for="importContractAddress">
										Contract Address
									</label>    

									<input type="text" class="form-control" id="importContractAddress" placeholder="0x....." maxlength="100000000" onkeydown="if(event.keyCode == 13){ ImportContractUI.addNewRequest(); }">  

								</div>    


								<button type="submit" class="btn btn-primary btn-block btn-sm" onclick="ImportContractUI.addNewRequest()">
									Request
								</button>`;
				
				
				
				
				
				
				let inject2 = `<div class="form-group">    

									<label for="importContractApiKey">
										Etherscan API Key
									</label>    
									<input type="text" class="form-control" id="importContractApiKey" placeholder="Optional: Etherscan API Key">  

								</div>      

								<div class="form-group">    
									<label for="importContractStorageLocation">Storage Location</label>    
									<input type="text" class="form-control" id="importContractStorageLocation" placeholder="/etherscan/contracts" value="/etherscan/contracts">  
								</div>        

								<div class="form-group">    
									<label for="importContractRetryAttempts">Retry Attempts on Failure</label>    
									<input type="text" class="form-control" id="importContractRetryAttempts" placeholder="3" value="3">  
								</div>`


				let injections = [inject1, inject2]
				
				for(let i = 0; i < tabs.length; i++) {
				
					tabs[i].e().classList.value = inactiveTabClasses;
				
				}
				
				tabs[tabID].e().classList.value = activeTabClasses;
				
				ImportContractUI.import.cardBodyContent.e().innerHTML = injections[tabID];
			
			}
			
			
			let client = plugin_iframe.createClient();
			
			// client, network, apiKey, storageLocation, retryAttemptsOnFailure
			ImportContractUI.plugin = new ImportEtherscanContractPlugin(client, ImportEtherscanContractPlugin.networks.ETHEREUM_MAINNET, "", "/etherscan/contracts", 3);
			

		</script>



	<div class="container">
	<div class="card mb-3 mt-2"><div class="card-body">
	

			<div class="row mb-3"><div class="col-sm-12">
		<h6>Status</h6> <div class="d-flex align-items-center">  <small> Running</small>  	<div class="spinner-border ms-auto ml-3"  style="width: 1.2rem; height: 1.2rem;" role="status" aria-hidden="true"></div>	</div>
		</div></div>
		
				<div class="row"><div class="col-sm-12">
		<h6>Task </h6>  <small> Waiting on API cooldown</small>  		</div>
		


		
		
		</div></div>
	
	
	





</div>
	
	<!---
<h6 class="mb-3 ml-1 mt-1">Import a Contract</h6>
<div class="card mb-3">
  <div class="card-header">
  
  
    <ul class="nav nav-pills card-header-pills nav-fill">
      <li class="nav-item">
        <a class="nav-link btn-sm" href="#" id="importContractImportTab">Import</a>
      </li>
      <li class="nav-item">
        <a class="nav-link bg-secondary active btn-sm" href="#" id="importContractSettingsTab">Settings</a>
      </li>
    </ul>
  </div>
  <div class="card-body" id="importContractCardBodyContent">
  
<div class="form-group">
    <label for="importContractApiKey">Etherscan API Key</label>
    <input type="text" class="form-control" id="importContractApiKey" placeholder="Optional: Etherscan API Key">
  </div>
  
  
  <div class="form-group">
    <label for="importContractStorageLocation">Storage Location</label>
    <input type="text" class="form-control" id="importContractStorageLocation" placeholder="/etherscan/contracts" value="/etherscan/contracts">
  </div>
  
    
  <div class="form-group">
    <label for="importContractRetryAttempts">Retry Attempts on Failure</label>
    <input type="text" class="form-control" id="importContractRetryAttempts" placeholder="3" value="3">
  </div>

  </div>
  
  
</div>--->


	
	
	
	

<h6 class="mb-3 ml-1 mt-1">Import a Contract</h6>
<div class="card mb-3">
  <div class="card-header">
  
  
    <ul class="nav nav-pills card-header-pills nav-fill">
      <li class="nav-item">
        <a class="nav-link bg-secondary active btn-sm" href="#" onclick="event.preventDefault(); ImportContractUI.import.setActive(0)" id="importContractImportTab">Import</a>
      </li>
      <li class="nav-item">
        <a class="nav-link btn-sm" onclick="event.preventDefault(); ImportContractUI.import.setActive(1)" href="#" id="importContractSettingsTab">Settings</a>
      </li>
    </ul>
  </div>
  <div class="card-body" id="importContractCardBodyContent">

  
  
  </div>
  
  
</div>



<script>

window.addEventListener('load', function () {
	ImportContractUI.import.setActive(0);
});

</script>


<h6 class="mb-3 ml-1 mt-1">Contracts for Import</h6>
	
	<div class="accordion" id="accordionExample">

		<!---
						<div class="card border border-1 mb-1">
							<div class="card-header mb-0" id="headingOne">
								<div class="mb-0">
									<button class="btn btn-link btn-sm btn-block text-truncate" type="button" data-toggle="collapse" data-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
										#0001: 0x9814542f4230ab166efef3363a2d85e20d8708c7
									</button>
								</div>
							</div>

							<div id="collapseOne" class="collapse show" aria-labelledby="headingOne" data-parent="#accordionExample">
							<div class="card-body">
							<div class="row mb-3"><div class="col-sm-12"><h6>Contract</h6><small>0x9814542f4230ab166efef3363a2d85e20d8708c7</small></div></div>
							<div class="row mb-3"><div class="col-sm-12">
							<h6>Status</h6><small>Not yet requested</small>
							</div></div>
							<div class="row"><div class="col-sm-12">
							<h6 class="mb-3">Storage Location</h6><small>  

							<textarea class="form-control" id="exampleFormControlTextarea1" rows="3" disabled>/etherscan/current_job/0x9814542f4230ab166efef3363a2d85e20d8708c7</textarea></small>
							</div></div>




							</div>
							</div>
						</div>

						<div class="card border border-1 mb-1">
						<div class="card-header mb-0" id="headingOne">
						<div class="mb-0">
						<button class="btn btn-link btn-sm btn-block text-truncate" type="button" data-toggle="collapse" data-target="#collapseOne2" aria-expanded="false" aria-controls="collapseOne2">
						0x9814542f4230ab166efef3363a2d85e20d8708c7
						</button>
						</div>
						</div>

						<div id="collapseOne2" class="collapse" aria-labelledby="headingOne" data-parent="#accordionExample">
						<div class="card-body">
						<div class="alert alert-success" role="alert">
						<small>This contract was successfully imported!</small>
						</div>
						<div class="row mb-3"><div class="col-sm-12"><h6>Contract</h6><small>0x9814542f4230ab166efef3363a2d85e20d8708c7</small></div></div>
						<div class="row"><div class="col-sm-12">
						<h6>Status</h6><small>Not yet requested</small>
						</div></div>



						</div>
						</div>
						</div>

						<div class="card border border-1 mb-3">
						<div class="card-header mb-0" id="headingOne">
						<div class="mb-0">
						<button class="btn btn-link btn-sm btn-block text-truncate" type="button" data-toggle="collapse" data-target="#collapseOne3" aria-expanded="false" aria-controls="collapseOne3">
						0x9814542f4230ab166efef3363a2d85e20d8708c7
						</button>
						</div>
						</div>

						<div id="collapseOne3" class="collapse" aria-labelledby="headingOne" data-parent="#accordionExample">
						<div class="card-body">

						<div class="alert alert-danger" role="alert">
						<small>This contract's source code was not available on Etherscan</small>
						</div>


						<div class="row mb-3"><div class="col-sm-12"><h6>Contract</h6><small>0x9814542f4230ab166efef3363a2d85e20d8708c7</small></div></div>
						<div class="row mb-3"><div class="col-sm-12">
						<h6>Status</h6><small>Not yet requested</small>
						</div></div>

						<button class="btn btn-sm btn-danger btn-block">Retry</button>



						</div>
						</div>
						</div>

						--->

	</div>





		</div>

		<script>
			// https://stackoverflow.com/questions/326069/how-to-identify-if-a-webpage-is-being-loaded-inside-an-iframe-or-directly-into-t
			function inIframe () {

			    try {

			        return window.self !== window.top;

			    } catch (e) {

			        return true;

			    }
			    
			}

			// otherwise, i would have to write stuff to change the default page when 
			// not being loaded in a remix client.
			if(!inIframe()) {

				window.location.replace("https://remix.ethereum.org");

			}

		</script>
		
		<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
	</body>
</html>